# QR Lock Screen Generator – Full Development Checklist

> **Purpose:** Each unchecked box represents a one‑story‑point task that a capable coding agent can complete in a single day or less.
> **Definition of Done (DoD) for every task:**
> – Code committed with tests green
> – Code reviewed & approved
> – Docs/comments updated where relevant
> – Lint & formatter pass
> – Feature visible in staging

Notes:
* use the mishka chelekom for ux/ui components where possible. Docs at @https://mishka.tools/chelekom/docs
* Use Heroicons for iconography (via Mishka or CoreComponents helpers).
* ensure the projects and tests run before considering a task complete.
* I'm using phoenix 1.8. Docs are at @https://hexdocs.pm/phoenix/1.8.0-rc.3/overview.html
* I'm using liveview 1.0.
* Use oban for background jobs
* use qr_code 3.2.0 for generating qr codes


---

## Development Process Overview
1. **Mockup Phase (✅ COMPLETED)**: Static HTML mockups have been created to visualize the user flow.
2. **Implementation Phase (⏳ IN PROGRESS)**: Develop the actual functional LiveView application using the mockups as reference.

All mockups are now complete and can be viewed under the `/mockup` routes. These provide the visual reference for implementing the functional application. The tasks below are for implementing the actual interactive application, not for creating additional mockups.

## Mockup Reference: User Flow
1. **Home** - Landing page with app introduction
2. **Create** - Enter URL for the QR code and display name (optional)
3. **Design** - Choose from available templates/styles for the QR code
4. **Preview** - See the QR code in the selected template
5. **Checkout** - Make payment
6. **Download** - Download the generated QR code and get installation instructions

---

## Epic 0 - Mockups ✅ COMPLETED
- [x] Create Phoenix controller/views under `/mockup` route showing plain html/css (no liveview, etc) examples of what the entire happy path flow will look like for this app. Review with me and make adjustments. I should be able to click buttons on each page to get to the next page. I shouldn't have to fill in any forms to continue or review. Make it look fun, exciting, and enticing for a customer to give me money. (Placeholders used for images)

## Epic 1 – QR Code Generation (Home & Create Pages)

### Story 1 – Home Page & Navigation
- [x] **Route:** Add routes for all LiveView pages following the same flow as the mockups: home, create, design, preview, checkout, and download.
- [x] **Landing Page:** Implement the functional home page following the mockup's design and content.
- [x] **CTA Button:** Add primary "Create my QR code" call-to-action button on home page with proper LiveView navigation.
- [x] **About Page:** Create a functional About page following the mockup design.
- [x] **Mobile Menu:** Implement responsive hamburger menu navigation for mobile devices with LiveView functionality.
- [x] **Styling:** Apply consistent styling with gradients, background elements, and clean UI from the mockups.
- [x] **Tests:** Add integration tests ensuring proper navigation between pages.

### Story 2 – URL Input Form (Create Page)
- [x] **URL Input:** Create functional form with URL field and optional display name field, referencing the mockup's layout.
- [x] **Validation:** Implement URL validation on form submission with LiveView feedback.
- [x] **Error Handling:** Display clear error messages for invalid URLs following the mockup's visual style.
- [x] **Continue & Back:** Implement navigation buttons with correct ordering (back left, continue right) and LiveView events.
- [x] **Responsive Design:** Ensure form works correctly on both mobile and desktop layouts as shown in mockups.
- [x] **Tests:** Add form submission tests including validation.
- [x] **Database Schema:** Create a comprehensive database schema with:
  - `qr_requests` table (id, url, name, token, template, preview_image_url, inserted_at, updated_at)
  - `orders` table (id, qr_request_id, status, amount_cents, currency, checkout_session_id, payment_intent_id, customer_id, metadata, email, error_message, idempotency_key, inserted_at, updated_at)
  - Create migrations and associated Ecto schemas
- [x] **Persistence:** Save the user's input to the database instead of just URL parameters, associate with a session token, and ensure data can be retrieved when using the back button.
- [x] **Session Management:** Implement secure session handling with Phoenix tokens and ensure proper expiration and rotation.

## Epic 2 – Template Selection (Design Page)

### Story 3 – Template Gallery
- [ ] **Template Display:** Create grid layout showing all available QR code template options.
- [ ] **Selection Mechanism:** Implement template selection with visual indicator for the active template.
- [ ] **Preview:** Show preview of how templates will look with the QR code.
- [ ] **Style Options:** Include at least 4 template styles (Pop Vibes, Ocean Blue, Sunny Side, Monochrome).
- [ ] **Navigation:** Add continue and back buttons for moving between create and preview pages.
- [ ] **Basic QR Generation:** Implement simple QR code generation for preview purposes with watermark.
- [ ] **Database Update:** Update the QR request record when a template is selected and load previously selected template when returning to this page.
- [ ] **Tests:** Validate template selection and navigation flow.

## Epic 3 – Preview & Checkout

### Story 4 – Preview Page
- [ ] **Phone Preview:** Create realistic phone mockup showing QR code on lock screen.
- [ ] **Info Panel:** Display details like URL, template name, and image resolution.
- [ ] **QR Composition:** Combine generated QR code with selected template for preview with watermark.
- [ ] **Optimizations:** Ensure QR code is properly sized and positioned for scanning.
- [ ] **Navigation:** Implement back and continue buttons to move between design and checkout.
- [ ] **Data Loading:** Ensure all data is loaded from the database rather than URL parameters and add a preview token for secure access.
- [ ] **Tests:** Verify preview rendering and navigation.

### Story 5 – Checkout Page
- [ ] **Order Summary:** Show order details and final price.
- [ ] **Payment Methods:** Display payment method options (credit card, PayPal, Apple Pay).
- [ ] **Form Fields:** Implement card information fields with basic validation.
- [ ] **Security Elements:** Add security indicators and payment processing information.
- [ ] **Navigation:** Implement back and complete purchase buttons with correct positioning.
- [ ] **Tests:** Validate checkout form fields and navigation.

## Epic 4 – Download & Installation (Download Page)

### Story 6 – Success & Download
- [ ] **Success Message:** Show confirmation message that the QR code is ready.
- [ ] **Download Button:** Implement main download button for the QR code image.
- [ ] **Installation Instructions:** Provide step-by-step instructions for setting as lock screen.
- [ ] **Device-Specific Guidance:** Include separate instructions for iPhone and Android users.
- [ ] **Create Another:** Add button to return to home to create another QR code.
- [ ] **Tests:** Verify download functionality and navigation.

## Epic 5 – Payment Processing

### Story 7 – Stripe Integration
- [ ] **Config:** Add `:stripity_stripe` config keys to `config/runtime.exs`; load from env.
- [ ] **Call to Stripe:** Implement `LockScreenQRCode.Payments.create_checkout_session/2` with price `500` cents, success/cancel URLs.
- [ ] **Controller:** Add `LockScreenQRCodeWeb.CheckoutController` with `create` action called via `POST /checkout`.
- [ ] **Redirect:** In LiveView, push redirect to Checkout session URL on success.
- [ ] **Security:** Verify user's chosen template & url stored server‑side, not in query params.
- [ ] **Integration test:** Stripe mock (ExVCR) ensures session creation payload.
- [ ] **Docs:** Document env var setup for Stripe keys.

### Story 8 – Webhook & Order Processing
- [ ] **Endpoint:** Add `post "/webhooks/stripe", StripeWebhookController, :handle` route (skip CSRF).
- [ ] **Verify signature:** Use `Stripe.Webhook.construct_event/3` with signing secret.
- [ ] **Persist order:** Insert `orders` table record with `status: :paid` and references to URL & template.
- [ ] **Broadcast Phoenix PubSub event `order:paid`.**
- [ ] **Retry logic:** Idempotency via event `id` uniqueness constraint.
- [ ] **Test:** Replay sample `checkout.session.completed` JSON fixture.
- [ ] **Docs:** Add webhook setup instructions.

## Epic 6 – QR Code Generation

### Story 9 – QR Code Generation Service
- [ ] **Service module:** Implement `LockScreenQRCode.Generator.generate(url)` returning PNG binary using `MishkaChelekom`.
- [ ] **Performance:** Ensure generation ≤ 300 ms for 95th percentile (bench mix task).
- [ ] **Scannability test:** Use `:qr_ex` lib in test to decode and assert result matches input URL.
- [ ] **Telemetry:** Emit event `[:lock_screen_qr_code, :generated]` with size in bytes.
- [ ] **Docs:** Add "QR Generation" developer doc.

### Story 10 – Image Composition
- [ ] **Service module:** `LockScreenQRCode.Compositor.compose(qr_png, template_path)` → final PNG 1170×2532.
- [ ] **Preview Watermark:** Add a distinct watermark (e.g., logo, text) to preview images generated before payment.
- [ ] **Use ImageMagick (`mogrify`)** for overlay with safe margins.
- [ ] **Store:** Upload to `LockScreenQRCode.Storage` (S3-compatible bucket) with 24h TTL signed URL.
- [ ] **Optimise:** Compress with `pngcrush`; target < 500 KB.
- [ ] **Integration test:** Generate composite, assert dimensions via `Mogrify.identify/1`.
- [ ] **Telemetry:** Emit `[:image, :composited]` duration metric.
- [ ] **Docs:** Explain safe‑zone mapping.

## Epic 7 – UX & Error Handling

### Story 11 – Responsive Layout & Accessibility
- [ ] **Tailwind breakpoints:** Ensure grid, forms, preview stack/horiz layouts on `sm`, `md`.
- [ ] **Viewport meta:** Add `<meta name="viewport"...>` in root layout.
- [ ] **Consistent button ordering:** Ensure Back buttons on left and Continue buttons on right on desktop.
- [ ] **Mobile-first layout:** Ensure proper stacking on mobile (Continue button above Back button).
- [ ] **Screen‑reader pass:** Run axe‑core; fix violations.
- [ ] **Docs:** Add responsive screenshots.

### Story 12 – Error Handling
- [ ] **Error component:** Create `LockScreenQRCodeWeb.ErrorComponent` with variant props (`url_error`, `stripe_error`).
- [ ] **Consistent style:** Red bg‑light, icon from Heroicons `exclamation-triangle`.
- [ ] **i18n:** All messages via gettext keys.
- [ ] **Logging:** Log errors with structured metadata to console & logger backend.
- [ ] **Test:** Simulate payment fail path, assert message renders.
- [ ] **Docs:** Add troubleshooting page.

## Epic 8 – Email Notifications (Optional)

### Story 13 – Email Collection & Sending
- [ ] **Form field:** Add optional email field with regex validation (`~r/^[\w.+-]+@...$/`).
- [ ] **DB:** Add `email` column to `orders` nullable.
- [ ] **Privacy notice:** Link to policy; no marketing spam.
- [ ] **Mailer:** Configure Swoosh + Mailgun adapter.
- [ ] **Template:** Create HTML/plain receipt email with download link.
- [ ] **Trigger:** After order is marked `:paid` and email present, call `LockScreenQRCode.Mailer.receipt/1`.
- [ ] **Retry:** Exponential back‑off on SMTP failure.
- [ ] **Unit test:** Reject malformed email, accept valid.
- [ ] **Test:** Swoosh test assertions email subject & link.
- [ ] **Docs:** Add email setup documentation.

## Global Tasks (Applies to All Stories)
- [ ] **CI pipeline:** Add GitHub Actions flow (mix format, credo, dialyzer, tests).
- [ ] **Dockerfile:** Multistage build using `hexpm/elixir:1.15-alpine`.
- [ ] **Staging env:** Deploy to Fly.io with secrets, auto‑migrations.
- [ ] **Monitoring:** Setup Prometheus + Grafana Dash via Fly.io metrics.
- [ ] **Security audit:** Run `mix hex.audit` and `mix deps.audit`.
- [ ] **Admin Dashboard:** Create a basic admin interface to view QR requests, orders, and analytics.
- [ ] **Rate Limiting:** Implement rate limiting to prevent abuse of the QR generation service.
- [ ] **Data Retention:** Implement policy for removing old unprocessed requests and preview images.
- [ ] **Browser Testing:** Verify application works correctly in Chrome, Firefox, Safari, and Edge.
- [ ] **Error Tracking:** Set up error reporting service (e.g., Honeybadger, Sentry).

---

## Roadmap Alignment
- Sprint 1: Stories 1–3 (User interface & navigation)
- Sprint 2: Stories 4–6 (Preview, checkout, download pages)
- Sprint 3: Stories 7–10 (Payment processing & QR generation)
- Sprint 4: Stories 11–13 (UX improvements & optional features)

---

## Development Process: Mockup Validation Workflow

This project includes a streamlined workflow for creating and validating mockups with AI assistance:

### Step 1: Create Phoenix Mockup Code
1. Write Elixir/Phoenix code for mockups under `/mockup` routes
2. Implement HTML/CSS (no LiveView needed) to design the mockup UI
3. Ensure mockups are linked together with navigation buttons

### Step 2: Generate Screenshots with Wallaby
1. Use the Wallaby test framework to automate screenshot capture
2. Example test code:
   ```elixir
   feature "Take screenshot of home page", %{session: session} do
     session
     |> visit(@base_url <> "/mockup/home")
     |> take_screenshot(name: @screenshot_prefix <> "home")
   end
   ```
3. Run `mix test test/lock_screen_qr_code_web/features/mockup_feature_test.exs` to generate screenshots
4. Screenshots are saved to `tmp/wallaby/screenshots/`

### Step 3: AI Analysis of Screenshots
1. Start the image analysis server:
   ```bash
   cd tmp/image-mcp && node image-mcp-server.js
   ```
2. The server runs on http://localhost:3031
3. The AI assistant can use this server to:
   - View images in base64 format
   - Get detailed image metadata
   - Analyze layout and content
   - Provide feedback on visual implementation

### Step 4: Iterate on Feedback
1. Make adjustments to mockup code based on AI feedback
2. Re-run Wallaby tests to generate new screenshots
3. AI analyzes updated screenshots for improvements
4. Repeat until mockups meet desired specifications

This workflow eliminates the need to manually upload screenshots for review and enables the AI assistant to provide detailed visual feedback on mockups throughout the development process.

---

## Appendix: Previous Mockup Creation Process (Completed)

The mockups for this project were created using the following workflow:

### Step 1: Create Phoenix Mockup Code
1. Write Elixir/Phoenix code for mockups under `/mockup` routes
2. Implement HTML/CSS (no LiveView needed) to design the mockup UI
3. Ensure mockups are linked together with navigation buttons

### Step 2: Generate Screenshots with Wallaby
1. Use the Wallaby test framework to automate screenshot capture
2. Example test code:
   ```elixir
   feature "Take screenshot of home page", %{session: session} do
     session
     |> visit(@base_url <> "/mockup/home")
     |> take_screenshot(name: @screenshot_prefix <> "home")
   end
   ```
3. Run `mix test test/lock_screen_qr_code_web/features/mockup_feature_test.exs` to generate screenshots
4. Screenshots are saved to `tmp/wallaby/screenshots/`

### Step 3: AI Analysis of Screenshots
1. Start the image analysis server:
   ```bash
   cd tmp/image-mcp && node image-mcp-server.js
   ```
2. The server runs on http://localhost:3031
3. The AI assistant can use this server to:
   - View images in base64 format
   - Get detailed image metadata
   - Analyze layout and content
   - Provide feedback on visual implementation

### Step 4: Iterate on Feedback
1. Make adjustments to mockup code based on AI feedback
2. Re-run Wallaby tests to generate new screenshots
3. AI analyzes updated screenshots for improvements
4. Repeat until mockups meet desired specifications

---

> **Next Steps:** Use the completed mockups as a visual reference to implement the functional LiveView application.


(Prompt for getting cursor.ai to continue, i will be copy/pasting this in after each story)
Go through each story and task in the .cursor-tasks.md file. Find the next story to work on. Review each unfinished task, correct any issues or ask for clarifications (only if absolutely needed!). Then proceed to create or edit files to complete each task. After you complete all the tasks in the story and all the tests pass, the linter pass, and there's no warnings, then update the file to check off any completed tasks. Run all safe commands without asking for approval. Continue with each task until you have finished the story, then stop and wait for me to review. do not continue to the next story until i've given the ok.  Do not checkin the code until I've given the ok. you are not done with the story until all tests pass, all linter pass, and no warnings.
